use std::fs::File;
use std::io::{BufWriter, Write};
use std::time::{Duration, SystemTime};

use futures::stream::{self, StreamExt};
use reqwest::Client;
use tokio::time::timeout;

const CONCURRENT_REQUESTS: usize = 100;
const REQUEST_TIMEOUT: u64 = 5;

#[derive(Debug)]
struct Playlist {
    name: String,
    url: String,
    entries: Vec<PlaylistEntry>,
    valid_count: usize,
    total_count: usize,
}

#[derive(Debug, Clone)]
struct PlaylistEntry {
    content: String,
    entry_type: EntryType,
    original_index: usize,
    is_valid: bool,
    response_time: Option<Duration>,
    error: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
enum EntryType {
    Header,
    Metadata,
    StreamUrl,
    Comment,
    Empty,
}

impl Playlist {
    fn new(name: String, url: String) -> Self {
        Self {
            name,
            url,
            entries: Vec::new(),
            valid_count: 0,
            total_count: 0,
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    print_banner();
    
    // Define multiple playlists
    let playlists = vec![
        Playlist::new(
            "Bangladesh Live TV".to_string(),
            "https://raw.githubusercontent.com/bugsfreeweb/LiveTVCollector/refs/heads/main/LiveTV/Bangladesh/LiveTV.m3u".to_string()
        ),
    ];

    println!("üé¨ ECNTV - Starting Multi-Playlist Validation");
    println!("=============================================");
    println!("üìä Playlists to process: {}", playlists.len());
    println!("‚ö° Concurrency: {} streams", CONCURRENT_REQUESTS);
    println!("‚è±Ô∏è  Timeout: {} seconds", REQUEST_TIMEOUT);
    println!("üîí Preserving original channel order");
    println!("---------------------------------------------");

    let client = create_http_client();
    let mut all_playlists = Vec::new();
    let mut total_valid = 0;
    let mut total_checked = 0;

    // Process each playlist
    for mut playlist in playlists {
        println!("\nüì∫ Processing: {}", playlist.name);
        println!("üîó Source: {}", playlist.url);
        
        match fetch_and_parse_playlist(&client, &playlist.url).await {
            Ok(entries) => {
                let original_count = entries.iter().filter(|e| e.entry_type == EntryType::StreamUrl).count();
                playlist.total_count = original_count;
                println!("üì• Loaded {} streams, {} total entries", original_count, entries.len());
                
                // Filter out unwanted streams before validation
                let (filtered_entries, filtered_count) = filter_unwanted_entries(entries);
                
                if filtered_count > 0 {
                    println!("üö´ Filtered out {} streams (adult/MP4/cinehub)", filtered_count);
                }
                
                // Extract stream URLs and indices for validation (without borrowing filtered_entries)
                let streams_to_validate: Vec<(usize, String)> = filtered_entries.iter()
                    .filter(|e| e.entry_type == EntryType::StreamUrl)
                    .map(|e| (e.original_index, e.content.clone()))
                    .collect();
                
                println!("üî¨ Validating {} streams...", streams_to_validate.len());
                
                let validation_results = validate_streams_batch(&client, &streams_to_validate).await;
                
                // Update entries with validation results
                let validated_entries = update_entries_with_validation(filtered_entries, validation_results);
                let valid_count = validated_entries.iter().filter(|e| e.is_valid).count();
                
                playlist.entries = validated_entries;
                playlist.valid_count = valid_count;
                
                total_valid += valid_count;
                total_checked += streams_to_validate.len();
                
                println!("‚úÖ {}: {}/{} streams valid", playlist.name, valid_count, streams_to_validate.len());
                
                all_playlists.push(playlist);
            }
            Err(e) => {
                println!("‚ùå Failed to process {}: {}", playlist.name, e);
            }
        }
    }

    // Generate output
    let output_file = "ECNTV_Validated_Playlist.m3u";
    write_enhanced_playlist(output_file, &all_playlists, total_valid, total_checked)?;

    print_summary(&all_playlists, total_valid, total_checked);
    Ok(())
}

fn print_banner() {
    println!(
        r#"
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë              üéØ ECNTV                 ‚ïë
    ‚ïë    Enhanced Content TV Validator      ‚ïë
    ‚ïë      Order-Preserving System          ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    "#
    );
}

fn create_http_client() -> Client {
    Client::builder()
        .timeout(Duration::from_secs(REQUEST_TIMEOUT))
        .tcp_keepalive(Duration::from_secs(10))
        .pool_max_idle_per_host(50)
        .user_agent("ECNTV-Validator/2.0")
        .build()
        .expect("Failed to create HTTP client")
}

async fn fetch_and_parse_playlist(client: &Client, url: &str) -> Result<Vec<PlaylistEntry>, Box<dyn std::error::Error>> {
    let response = client.get(url).send().await?;
    let content = response.text().await?;
    
    let mut entries = Vec::new();
    let mut index = 0;
    
    for line in content.lines() {
        let line = line.trim();
        let entry_type = classify_line(line);
        
        let entry = PlaylistEntry {
            content: line.to_string(),
            entry_type,
            original_index: index,
            is_valid: false,
            response_time: None,
            error: None,
        };
        
        entries.push(entry);
        index += 1;
    }
    
    Ok(entries)
}

fn classify_line(line: &str) -> EntryType {
    if line.is_empty() {
        EntryType::Empty
    } else if line == "#EXTM3U" {
        EntryType::Header
    } else if line.starts_with("#EXTINF") {
        EntryType::Metadata
    } else if line.starts_with("#EXT") || line.starts_with("#PLAYLIST") || line.starts_with("#EXTVLCOPT") {
        EntryType::Comment
    } else if line.starts_with("http") {
        EntryType::StreamUrl
    } else {
        EntryType::Comment
    }
}

fn filter_unwanted_entries(entries: Vec<PlaylistEntry>) -> (Vec<PlaylistEntry>, usize) {
    let mut filtered = Vec::new();
    let mut skip_next_url = false;
    let mut filtered_count = 0;

    let mut i = 0;
    while i < entries.len() {
        let entry = &entries[i];
        
        // Check if current entry should be filtered
        let should_filter = match entry.entry_type {
            EntryType::Metadata => {
                // Check for adult content in metadata
                entry.content.to_uppercase().contains("ADULT") || 
                entry.content.contains("group-title=\"ADULT")
            }
            EntryType::StreamUrl => {
                // Check for cinehub24.com or .mp4 in URLs
                entry.content.contains("cinehub24.com") ||
                entry.content.to_lowercase().ends_with(".mp4") ||
                entry.content.contains(".mp4?")
            }
            _ => false,
        };

        if should_filter {
            // If it's metadata, also skip the next URL entry
            if entry.entry_type == EntryType::Metadata {
                skip_next_url = true;
                filtered_count += 1; // Count the metadata as filtered
            } else if entry.entry_type == EntryType::StreamUrl {
                filtered_count += 1;
            }
            i += 1;
        } else if skip_next_url && entry.entry_type == EntryType::StreamUrl {
            // Skip this URL because previous metadata was filtered
            filtered_count += 1;
            skip_next_url = false;
            i += 1;
        } else {
            // Keep this entry
            skip_next_url = false;
            filtered.push(entries[i].clone());
            i += 1;
        }
    }

    (filtered, filtered_count)
}

async fn validate_streams_batch(client: &Client, streams: &[(usize, String)]) -> Vec<(usize, bool, Option<Duration>, Option<String>)> {
    let total_streams = streams.len();
    
    let validation_results: Vec<(usize, bool, Option<Duration>, Option<String>)> = stream::iter(streams.iter().enumerate())
        .map(|(batch_index, (original_index, url))| {
            let client = client.clone();
            let url = url.clone();
            let original_index = *original_index;
            
            async move {
                let check_start = std::time::Instant::now();
                let validation_result = perform_deep_validation(&client, &url).await;
                let response_time = check_start.elapsed();

                // Enhanced logging with progress and details
                let progress = format!("[{}/{}]", batch_index + 1, total_streams);
                let channel_name = extract_channel_name_from_url(&url)
                    .unwrap_or_else(|| shorten_url(&url));
                
                if validation_result.is_valid {
                    let speed = format!("{}ms", response_time.as_millis());
                    println!("   ‚úÖ {} {} - {} ({})", progress, channel_name, "LIVE", speed);
                } else {
                    let error_msg = validation_result.error.as_deref().unwrap_or("Unknown error");
                    println!("   ‚ùå {} {} - {}", progress, channel_name, error_msg);
                }
                
                (original_index, validation_result.is_valid, Some(response_time), validation_result.error)
            }
        })
        .buffer_unordered(CONCURRENT_REQUESTS)
        .collect()
        .await;
    
    validation_results
}

fn update_entries_with_validation(
    entries: Vec<PlaylistEntry>, 
    validation_results: Vec<(usize, bool, Option<Duration>, Option<String>)>
) -> Vec<PlaylistEntry> {
    // Create a map for quick lookup
    let mut result_map = std::collections::HashMap::new();
    for (index, is_valid, response_time, error) in validation_results {
        result_map.insert(index, (is_valid, response_time, error));
    }
    
    // Update entries with validation results
    let mut updated_entries = entries;
    for entry in &mut updated_entries {
        if entry.entry_type == EntryType::StreamUrl {
            if let Some((is_valid, response_time, error)) = result_map.get(&entry.original_index) {
                entry.is_valid = *is_valid;
                entry.response_time = *response_time;
                entry.error = error.clone();
            }
        }
    }
    
    updated_entries
}

async fn perform_deep_validation(client: &Client, url: &str) -> ValidationResult {
    // First, try HEAD request for fast checking
    if let Ok(response) = timeout(
        Duration::from_secs(REQUEST_TIMEOUT),
        client.head(url).send()
    ).await {
        if let Ok(resp) = response {
            let status = resp.status();
            if status.is_success() {
                return ValidationResult { is_valid: true, error: None };
            }
        }
    }
    
    // Fallback: Try GET with range for deeper validation
    if let Ok(response) = timeout(
        Duration::from_secs(REQUEST_TIMEOUT),
        client.get(url)
            .header("Range", "bytes=0-1024") // Get first 1KB for deeper check
            .send()
    ).await {
        match response {
            Ok(resp) if resp.status().is_success() || resp.status().as_u16() == 206 => {
                // For HLS streams, check if content looks like a playlist
                if url.contains(".m3u8") {
                    if let Ok(text) = resp.text().await {
                        if text.contains("#EXTM3U") || text.contains("#EXTINF") {
                            return ValidationResult { is_valid: true, error: None };
                        } else {
                            return ValidationResult { 
                                is_valid: false, 
                                error: Some("Invalid HLS playlist".to_string()) 
                            };
                        }
                    }
                }
                ValidationResult { is_valid: true, error: None }
            }
            Ok(resp) => ValidationResult { 
                is_valid: false, 
                error: Some(format!("HTTP {}", resp.status())) 
            },
            Err(e) => ValidationResult { 
                is_valid: false, 
                error: Some(format!("Request failed: {}", e)) 
            },
        }
    } else {
        ValidationResult { 
            is_valid: false, 
            error: Some("Timeout".to_string()) 
        }
    }
}

fn write_enhanced_playlist(
    output_file: &str, 
    playlists: &[Playlist], 
    total_valid: usize,
    total_checked: usize,
) -> Result<(), Box<dyn std::error::Error>> {
    let file = File::create(output_file)?;
    let mut writer = BufWriter::new(file);
    
    // Write enhanced header with validation details
    writeln!(writer, "#EXTM3U")?;
    writeln!(writer, "#PLAYLIST:ECNTV - Enhanced Content TV")?;
    writeln!(writer, "#GENERATED-BY: ECNTV Validator v2.0")?;
    writeln!(writer, "#VALIDATION-DATE: {}", get_simple_timestamp())?;
    writeln!(writer, "#TOTAL-PLAYLISTS: {}", playlists.len())?;
    writeln!(writer, "#TOTAL-STREAMS-CHECKED: {}", total_checked)?;
    writeln!(writer, "#TOTAL-VALID-STREAMS: {}", total_valid)?;
    writeln!(writer, "#SUCCESS-RATE: {:.1}%", (total_valid as f32 / total_checked as f32) * 100.0)?;
    writeln!(writer, "#FILTERS-APPLIED: ADULT, .mp4, cinehub24.com")?;
    writeln!(writer, "#ORDER-PRESERVATION: Original channel order maintained")?;
    writeln!(writer, "########################################")?;
    
    // Write each playlist's streams in ORIGINAL ORDER
    for playlist in playlists {
        if playlist.valid_count > 0 {
            writeln!(writer, "#EXTINF:-1,üéØ {} ‚ö° [{} valid / {} total]", 
                playlist.name, playlist.valid_count, playlist.total_count)?;
            writeln!(writer, "#EXTVLCOPT:network-caching=1000")?;
            
            // Write entries in EXACT original order, only including valid streams
            let mut last_metadata: Option<&PlaylistEntry> = None;
            
            for entry in &playlist.entries {
                match entry.entry_type {
                    EntryType::Header => {
                        // Skip - we already wrote our own header
                    }
                    EntryType::Metadata => {
                        last_metadata = Some(entry);
                    }
                    EntryType::StreamUrl => {
                        if entry.is_valid {
                            // Write the preceding metadata if it exists
                            if let Some(metadata) = last_metadata.take() {
                                writeln!(writer, "{}", metadata.content)?;
                            }
                            writeln!(writer, "{}", entry.content)?;
                        } else {
                            // Skip this stream and clear the metadata
                            last_metadata = None;
                        }
                    }
                    EntryType::Comment | EntryType::Empty => {
                        // Preserve comments and empty lines between valid streams
                        if last_metadata.is_none() {
                            writeln!(writer, "{}", entry.content)?;
                        }
                    }
                }
            }
            
            writeln!(writer, "#EXTINF:-1,‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")?;
            writeln!(writer, "#EXTVLCOPT:network-caching=1000")?;
        }
    }
    
    // Write footer
    writeln!(writer, "########################################")?;
    writeln!(writer, "#END-OF-PLAYLIST")?;
    writeln!(writer, "#ECNTV - Quality Streams Only - Order Preserved")?;
    
    writer.flush()?;
    println!("\nüíæ Playlist saved: {}", output_file);
    Ok(())
}

fn print_summary(playlists: &[Playlist], total_valid: usize, total_checked: usize) {
    println!("\n=============================================");
    println!("üéØ ECNTV - VALIDATION COMPLETE");
    println!("=============================================");
    println!("üìä OVERALL SUMMARY:");
    println!("   Total Playlists: {}", playlists.len());
    println!("   Total Checked: {}", total_checked);
    println!("   Total Valid: {}", total_valid);
    println!("   Success Rate: {:.1}%", (total_valid as f32 / total_checked as f32) * 100.0);
    println!("   Order Preservation: ‚úÖ Original order maintained");
    println!("---------------------------------------------");
    
    for playlist in playlists {
        let valid_rate = if !playlist.entries.is_empty() {
            let stream_count = playlist.entries.iter().filter(|e| e.entry_type == EntryType::StreamUrl).count();
            if stream_count > 0 {
                (playlist.valid_count as f32 / stream_count as f32) * 100.0
            } else { 0.0 }
        } else { 0.0 };
        
        println!("üì∫ {}:", playlist.name);
        println!("      Original: {} streams", playlist.total_count);
        println!("      Valid: {} streams ({:.1}%)", 
            playlist.valid_count, valid_rate);
    }
    
    println!("=============================================");
    println!("üö´ Active Filters:");
    println!("   ‚Ä¢ Adult content (group-title=\"ADULT LIVE\")");
    println!("   ‚Ä¢ cinehub24.com domains");
    println!("   ‚Ä¢ .mp4 format streams");
    println!("=============================================");
}

// Helper functions
fn extract_channel_name_from_url(url: &str) -> Option<String> {
    // Extract domain or last part of URL for identification
    if let Some(domain_start) = url.find("://") {
        let domain_end = url[domain_start + 3..].find('/').unwrap_or(url.len() - domain_start - 3);
        let domain = &url[domain_start + 3..domain_start + 3 + domain_end];
        Some(domain.to_string())
    } else {
        None
    }
}

fn shorten_url(url: &str) -> String {
    if url.len() > 40 {
        format!("{}...", &url[..40])
    } else {
        url.to_string()
    }
}

fn get_simple_timestamp() -> String {
    let now = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    
    let days = now / 86400;
    let hours = (now % 86400) / 3600;
    let minutes = (now % 3600) / 60;
    
    format!("Day {} - {:02}:{:02} UTC", days, hours, minutes)
}

#[derive(Debug)]
struct ValidationResult {
    is_valid: bool,
    error: Option<String>,
}
